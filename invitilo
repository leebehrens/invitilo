#!/usr/bin/env bash

# Invitilo: An enhanced command prompt
# Run using . or source:
#   . invitilo [options] [theme]
#   source invitilo [options] [theme]

invitilo_ensure_sourced() {
    # Ensure the script is sourced.
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        echo "Error: This script must be sourced. Use 'source invitilo' or '. invitilo'."
        exit 1
    fi
}

# Most readonly values (constants) are used in themes. Wrapping them all in a
# function allows using a single shellcheck disable directive for all of them.
# shellcheck disable=SC2034
invitilo_init() {
    # Effects - Wrapped in \[\] to prevent bash from counting them as displayed characters.
    readonly RESET='\[\e[0m\]'
    readonly BOLD='\[\e[1m\]'
    readonly DIM='\[\e[2m\]'
    readonly NORMAL='\[\e[22m\]'
    readonly ITALIC='\[\e[3m\]'
    readonly NOITALIC='\[\e[23m\]'
    readonly UNDERLINE='\[\e[4m\]'
    readonly NOUNDERLINE='\[\e[24m\]'
    readonly BLINK='\[\e[5m\]'
    readonly NOBLINK='\[\e[25m\]'
    readonly REVERSE='\[\e[7m\]'
    readonly NOREVERSE='\[\e[27m\]'
    readonly STRIKE='\[\e[9m\]'
    readonly NOSTRIKE='\[\e[29m\]'

    # Forground colors - Wrapped in \[\] to prevent bash from counting them as displayed characters.
    readonly BLACK='\[\e[30m\]'
    readonly RED='\[\e[31m\]'
    readonly GREEN='\[\e[32m\]'
    readonly YELLOW='\[\e[33m\]'
    readonly BLUE='\[\e[34m\]'
    readonly MAGENTA='\[\e[35m\]'
    readonly CYAN='\[\e[36m\]'
    readonly WHITE='\[\e[37m\]'

    # Background colors - Wrapped in \[\] to prevent bash from counting them as displayed characters.
    readonly BLACKBG='\[\e[40m\]'
    readonly REDBG='\[\e[41m\]'
    readonly GREENBG='\[\e[42m\]'
    readonly YELLOWBG='\[\e[43m\]'
    readonly BLUEBG='\[\e[44m\]'
    readonly MAGENTABG='\[\e[45m\]'
    readonly CYANBG='\[\e[46m\]'
    readonly WHITEBG='\[\e[47m\]'

    # Some themes may find the OS type handy. E.g., there are definite display differences
    # between Linux standalone vs Linux on WSL.
    case "$OSTYPE" in
        linux*)
            INVITILO_OS="linux"
            if env | grep -q "WSL"; then
                # Running in WSL
                INVITILO_OS="linux-wsl"
            fi
            ;;
        darwin*)  INVITILO_OS="macos";;
        cygwin*)  INVITILO_OS="windows-cygwin";;
        msys*)    INVITILO_OS="windows-msys";;
        *bsd*)    INVITILO_OS="bsd-$OSTYPE";;
        *)        INVITILO_OS="unknown";;
    esac
    readonly INVITILO_OS

    # shellcheck disable=SC2155 # OK for script to crash if the var is not set.
    readonly INVITILO_ROOT_DIR="$(dirname "${BASH_SOURCE[0]}")"
    readonly INVITILO_THEME_DIR="${INVITILO_ROOT_DIR}/themes"
    readonly INVITILO_THEME_EXT=".theme"
}
invitilo_init

invitilo_list() {
    # List available themes without the .pi-theme extension
    echo "Available themes (* = active):"
    for theme in "${INVITILO_THEME_DIR}"/*"${INVITILO_THEME_EXT}"; do
        theme_name=$(basename "$theme" ${INVITILO_THEME_EXT})
        if [ "$theme_name" == "$INVITILO_THEME" ]; then
            echo "* $theme_name"
        else
            echo "  $theme_name"
        fi
    done
}


invitilo_start() {
    invitilo_ensure_sourced

    # Save the original PS1 prompt if it hasn't been saved already
    if [ -z "${INVITILO_PS1+x}" ]; then
        export INVITILO_PS1="$PS1"
    fi

    # Verify the desired theme exists, falling back to the default theme. If the default
    # can't befound either, then revert to the original prompt.
    THEME_NAME="$1"
    if [ -z "$THEME_NAME" ]; then
        THEME_NAME="default"
    fi
    if [ ! -f "${INVITILO_THEME_DIR}/${THEME_NAME}${INVITILO_THEME_EXT}" ]; then
        echo "Prompt theme not found: ${THEME_NAME}"
        THEME_NAME="default"
        if [ ! -f "${INVITILO_THEME_DIR}/${THEME_NAME}${INVITILO_THEME_EXT}" ]; then
            echo "Default prompt theme not found; using orignal prompt."
            stop_invitilo
            exit 1
        fi
    fi

    export INVITILO_THEME="${THEME_NAME}"

    # Unload the previous theme if it exists.
    unset invitilo_theme_init
    unset invitilo_theme_prompt

    # Load the new theme.
    # shellcheck disable=SC1090 # ShellCheck can't detect the theme file.
    source "${INVITILO_THEME_DIR}/${THEME_NAME}${INVITILO_THEME_EXT}"


    invitilo_theme_prompt

    PROMPT_COMMAND=invitilo

    echo "Invitilo: Prompt theme ${THEME_NAME} loaded."
}

invitilo_stop() {
    invitilo_ensure_sourced
    unset PROMPT_COMMAND
    PS1="$INVITILO_PS1"
    unset INVITILO_PS1
    unset INVITILO_THEME
}


invitilo_newline() {
    # Detect whether at the leftmost column to allow starting the prompt at the beginning of
    # the next line. Useful when the last executed command leaves the cursor in the middle of
    # the line (e.g., after running base64 -w0 <filename>).
    # VSCode's interprocess communication to remote shells (e.g., WSL) doesn't handle \e[6n
    # well, so skip detection if running in that environment.
    NEWLINE=""
    # if ! env | grep -q -m 1 "VSCODE_"; then
    if [ -z "$VSCODE_IPC_HOOK_CLI" ]; then
        # \[ and \] aren't needed here, and if used they will be displayed.
        IFS=';' read -rsdR -p $'\e[s\e[6n' _ COL
        echo -ne "\e[u"
        if (( COL > 1 )); then
            NEWLINE="${BOLD}${RED}␤${RESET}\n"
        fi
    fi
}

invitilo_python_venv() {
    # Get the current Python virtual environment name.
    VENV=""
    if [ -n "$VIRTUAL_ENV_PROMPT" ]; then
        VENV="${VENV_PREFIX}${VIRTUAL_ENV_PROMPT}${VENV_SUFFIX}"
    fi
}

invitilo_git_branch() {
    # Get the current git local and remote branch names.
    #GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    GIT_REMOTE_BRANCH=""
    GIT_BRANCH=$(git branch 2>/dev/null | grep '\*' | sed 's/* //')
    if [[ -n "$GIT_BRANCH" ]]; then
        GIT_BRANCH="${GIT_BRANCH_PREFIX}${GIT_BRANCH}${GIT_BRANCH_SUFFIX}"
    fi
}

invitilo_status() {
    # Get the status of the last command.
    if (( STATUS == 0 )); then
        STATUS="${SUCCESS_STATUS}"
    else
        STATUS="${ERROR_STATUS}"
    fi
}


invitilo() {
    # Need to get the status of the last command before calling any functions.
    # initilo_status will update the value for use in the prompt.
    STATUS=$?

    # Ideally, these functions would ever need to be called once. But we call
    # them here to ensure the values of the variables are sure to be unaffected
    # by other processes.
    # invitilo_init_colors
    invitilo_theme_init

    # The values of the variables set by these functions may vary by the state
    # of the system (e.g., where the cursor is on the line, if a Python virtual
    # environment is active, etc.).
    invitilo_newline
    invitilo_python_venv
    invitilo_git_branch
    invitilo_status

    # Call the make_prompt function defined in the theme file
    # shellcheck disable=SC2119
    invitilo_theme_prompt
    PS1="${PROMPT}"
}

case "$1" in
    --help|-h)
        cat <<EOF
NAME
    invitilo - An enhanced command prompt

SYNOPSIS
    . invitilo [option] [theme]
    source invitilo [option] [theme]

DESCRIPTION
    A customizable command prompt with theme support.

OPTIONS
    -h, --help   Show this help message.
    --list       List available themes.
    --stop       Stop invitilo and restore the original prompt.
    [theme]      Start invitilo with the specified theme. The default theme
                 is used if not specified.
EOF
        ;;
    --list)
        invitilo_list
        ;;
    --stop)
        invitilo_stop
        ;;
    --version)
        cat VERSION
        echo "----"
        VERSION=$(head -n 1 VERSION | (IFS=' ' read -r _ ver ; echo "$ver"))
        echo "VERSION=$VERSION"
        if [[ "$VERSION" == *"-"* ]]; then
            PRERELEASE=true
        else
            PRERELEASE=false
        fi
        echo "PRERELEASE=$PRERELEASE"
        ;;
    *)
        if [[ "$1" == -* ]]; then
            echo "Error: Inavlid option. Use -h or --help for usage information."
            exit 1
        fi
        invitilo_start "$1"
        ;;
esac
